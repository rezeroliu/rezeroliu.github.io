import{_ as i,c as s,o as a,d as n}from"./app-CvT9GcGl.js";const t={},e=n(`<h1 id="leetcode-55-跳跃游戏" tabindex="-1"><a class="header-anchor" href="#leetcode-55-跳跃游戏"><span>Leetcode.55 跳跃游戏</span></a></h1><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 <strong>示例1</strong>：  输入**: [2,3,1,1,4]  输出: true  解释: 位置0 -&gt; 位置1 -&gt; 末尾 <strong>示例2</strong>：  输入: [3,2,1,0,4]  输出: false  解释: 最远到达位置3，之后再无法向后跳</p></blockquote><h2 id="思路一-贪心法" tabindex="-1"><a class="header-anchor" href="#思路一-贪心法"><span>思路一：贪心法</span></a></h2><p>贪心算法的思路跟简单，从前向后遍历每个位置，若当前位置能达到，则更新可以到达的最远的位置，最后若能到达最后一个位置返回true。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> canJump</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> maxposition</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nums</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(maxposition </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> i){  </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 能到达当前位置则更新可以到达的最远位置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">                maxposition </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> maxposition </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> nums[i]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> maxposition </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> nums[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            else</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{   </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//当前位置不可到达，返回false</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">                return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="思路二-从后往前遍历-不知道叫什么方法好" tabindex="-1"><a class="header-anchor" href="#思路二-从后往前遍历-不知道叫什么方法好"><span>思路二：从后往前遍历（不知道叫什么方法好）</span></a></h2><p>如果最后一个位置可以到达，那在它的前面一定存在位置i,i到最后一个位置的距离小于等于nums[i]。这么讲好像不是很清楚，先看代码吧</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> canJump</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//到达后一个位置需要的步数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nums</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(nums[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> n){ </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 当前位置可跳跃的距离大于到后一个需要到达位置的距离，那么它前一个位置只要能到达自己就可以</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">                n </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            else</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{    </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 如果当前位置无法到达后一个需要到达的位置，则需要跳跃的距离+1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">                n</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体来说，每个位置都希望找到它前面最近(n=1)的一个可以到达自己的位置，如果找到这个位置pos，那继续往前找到可以到达pos的位置，直到搜索到起始位置。 以[2,3,1,1,4]为例，首先n=1，接下来：nums[3] &gt;= n=1可以到达位置4（n更新为1）-&gt; nums[2] &gt;= n=1可以到达位置3（n更新为1）-&gt; nums[1] &gt;= n=1可以到达位置2（n更新为1）-&gt; nums[0] &gt;= n=1可以到达位置1（n更新为1） 但是对于[3,2,1,0,4]，初始n=1，nums[3] &lt; n=1无法到达位置4（n更新为2）-&gt; nums[2] &lt; n=2无法到达位置4（n更新为3）-&gt; nums[1] &lt; n=3无法到达位置4（n更新为4）-&gt; nums[0] &lt; n=1无法到达位置4（n更新为2）</p>`,9),l=[e];function h(k,p){return a(),s("div",null,l)}const d=i(t,[["render",h],["__file","leetcode-45.html.vue"]]),g=JSON.parse('{"path":"/code/leetcode/leetcode-45.html","title":"Leetcode.55 跳跃游戏","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2020-6-02","category":["刷题笔记"],"tag":["贪心算法"],"permalink":"/code/leetcode/leetcode-45.html","description":"Leetcode.55 跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 示例1： 输入**: [2,3,1,1,4] 输出: true 解释: 位置0 -> 位置1 -> 末尾 示例2： 输入: [3,2,1,0,4] 输出: false 解释: 最远到达位...","head":[["meta",{"property":"og:url","content":"https://rezeroliu.github.io/code/leetcode/leetcode-45.html"}],["meta",{"property":"og:site_name","content":"旺仔珍知棒"}],["meta",{"property":"og:title","content":"Leetcode.55 跳跃游戏"}],["meta",{"property":"og:description","content":"Leetcode.55 跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 示例1： 输入**: [2,3,1,1,4] 输出: true 解释: 位置0 -> 位置1 -> 末尾 示例2： 输入: [3,2,1,0,4] 输出: false 解释: 最远到达位..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-24T13:17:42.000Z"}],["meta",{"property":"article:author","content":"Rezero.Liu"}],["meta",{"property":"article:tag","content":"贪心算法"}],["meta",{"property":"article:published_time","content":"2020-06-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-24T13:17:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Leetcode.55 跳跃游戏\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-02T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-24T13:17:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Rezero.Liu\\",\\"url\\":\\"https://rezeroliu.github.io\\"}]}"]]},"headers":[{"level":2,"title":"思路一：贪心法","slug":"思路一-贪心法","link":"#思路一-贪心法","children":[]},{"level":2,"title":"思路二：从后往前遍历（不知道叫什么方法好）","slug":"思路二-从后往前遍历-不知道叫什么方法好","link":"#思路二-从后往前遍历-不知道叫什么方法好","children":[]}],"git":{"createdTime":1732454262000,"updatedTime":1732454262000,"contributors":[{"name":"LuckyGoGo","email":"7643936+luckygogo@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":2.32,"words":695},"filePathRelative":"code/leetcode/leetcode-45.md","localizedDate":"2020年6月2日","excerpt":"\\n<blockquote>\\n<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。\\n<strong>示例1</strong>：\\n 输入**: [2,3,1,1,4]\\n 输出: true\\n 解释: 位置0 -&gt; 位置1 -&gt; 末尾\\n<strong>示例2</strong>：\\n 输入: [3,2,1,0,4]\\n 输出: false\\n 解释: 最远到达位置3，之后再无法向后跳</p>\\n</blockquote>\\n<h2>思路一：贪心法</h2>\\n<p>贪心算法的思路跟简单，从前向后遍历每个位置，若当前位置能达到，则更新可以到达的最远的位置，最后若能到达最后一个位置返回true。</p>","autoDesc":true}');export{d as comp,g as data};
